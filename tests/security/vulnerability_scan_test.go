package security

import (
	"context"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"
)

// VulnerabilityScanTestSuite tests the vulnerability scanner
type VulnerabilityScanTestSuite struct {
	suite.Suite
	scanner      *VulnerabilityScanner
	testDir      string
	testFiles    []string
}

// SetupSuite sets up the test suite
func (suite *VulnerabilityScanTestSuite) SetupSuite() {
	// Create temporary test directory
	tempDir, err := os.MkdirTemp("", "security-scan-test")
	suite.Require().NoError(err)
	suite.testDir = tempDir

	// Create scanner with test configuration
	config := &ScanConfig{
		ProjectRoot:      tempDir,
		ScanDependencies: true,
		ScanCode:         true,
		ScanSecrets:      true,
		ScanInsecureCode: true,
		MaxDepth:         5,
		Timeout:          1 * time.Minute,
	}

	scanner, err := NewVulnerabilityScanner(config)
	suite.Require().NoError(err)
	suite.scanner = scanner

	// Create test files with vulnerabilities
	suite.createTestFilesWithVulnerabilities()
}

// TearDownSuite cleans up after the test suite
func (suite *VulnerabilityScanTestSuite) TearDownSuite() {
	// Clean up test files
	for _, file := range suite.testFiles {
		os.Remove(file)
	}
	os.RemoveAll(suite.testDir)
}

// createTestFilesWithVulnerabilities creates test files with various security issues
func (suite *VulnerabilityScanTestSuite) createTestFilesWithVulnerabilities() {
	// Create a Go file with various security issues
	goFile := filepath.Join(suite.testDir, "vulnerable.go")
	goCode := `
package main

import (
	"crypto/md5"
	"crypto/sha1"
	"database/sql"
	"fmt"
	"log"
	"math/rand"
	"os/exec"
)

func vulnerableFunction(password string) {
	// Hardcoded password
	dbPassword := "supersecret123"

	// SQL injection vulnerability
	query := fmt.Sprintf("SELECT * FROM users WHERE password = '%s'", password)
	db.Query(query)

	// Weak hash algorithm
	hash := md5.Sum([]byte(password))
	sha1Hash := sha1.Sum([]byte(password))

	// Command injection vulnerability
	cmd := exec.Command("rm", "-rf", "/"+password)
	cmd.Run()

	// Weak random number generation
	random := rand.Intn(100)

	log.Printf("Hash: %x, SHA1: %x, Random: %d, Password: %s", hash, sha1Hash, random, dbPassword)
}

// AWS Access Key hardcoded
var awsAccessKey = "AKIAIOSFODNN7EXAMPLE"
var awsSecret = "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
var githubToken = "ghp_1234567890abcdef1234567890abcdef12345678"
`
	err := os.WriteFile(goFile, []byte(goCode), 0644)
	suite.Require().NoError(err)
	suite.testFiles = append(suite.testFiles, goFile)

	// Create a config file with secrets
	configFile := filepath.Join(suite.testDir, "config.json")
	configCode := `
{
	"database": {
		"connection_string": "postgresql://admin:password123@localhost:5432/mydb",
		"api_key": "sk-1234567890abcdef1234567890abcdef12345678"
	},
	"jwt_secret": "my-super-secret-jwt-key-that-is-long-enough-but-still-hardcoded"
}
`
	err = os.WriteFile(configFile, []byte(configCode), 0644)
	suite.Require().NoError(err)
	suite.testFiles = append(suite.testFiles, configFile)

	// Create a go.mod file
	goModFile := filepath.Join(suite.testDir, "go.mod")
	goModCode := `module vulnerable-app

go 1.21

require (
	github.com/gorilla/websocket v1.4.2
	github.com/gin-gonic/gin v1.9.1
	golang.org/x/crypto v0.0.0-20220722155217-630584e8d5aa
)
`
	err = os.WriteFile(goModFile, []byte(goModCode), 0644)
	suite.Require().NoError(err)
	suite.testFiles = append(suite.testFiles, goModFile)

	// Create a file with private key
	privateKeyFile := filepath.Join(suite.testDir, "private.pem")
	privateKeyCode := `-----BEGIN RSA PRIVATE KEY-----
MIIEpAIBAAKCAQEAwJNLvZ...
-----END RSA PRIVATE KEY-----`
	err = os.WriteFile(privateKeyFile, []byte(privateKeyCode), 0644)
	suite.Require().NoError(err)
	suite.testFiles = append(suite.testFiles, privateKeyFile)
}

// Test Cases

func (suite *VulnerabilityScanTestSuite) TestVulnerabilityScan() {
	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Minute)
	defer cancel()

	// Run the vulnerability scan
	report, err := suite.scanner.Scan(ctx)
	suite.Require().NoError(err)

	// Verify report structure
	suite.NotNil(report)
	suite.Greater(report.TotalFindings, 0, "Should find vulnerabilities in test files")
	suite.NotEmpty(report.Findings)
	suite.NotNil(report.Summary)

	// Should find critical vulnerabilities (secrets)
	criticalFound := false
	for _, finding := range report.Findings {
		if finding.Severity == "critical" {
			criticalFound = true
			break
		}
	}
	suite.True(criticalFound, "Should find critical vulnerabilities")

	// Should find high vulnerabilities (insecure code)
	highFound := false
	for _, finding := range report.Findings {
		if finding.Severity == "high" {
			highFound = true
			break
		}
	}
	suite.True(highFound, "Should find high severity vulnerabilities")

	// Should find exposed secrets
	secretsFound := false
	for _, finding := range report.Findings {
		if finding.Type == "exposed_secret" {
			secretsFound = true
			break
		}
	}
	suite.True(secretsFound, "Should find exposed secrets")

	// Should find insecure code
	insecureCodeFound := false
	for _, finding := range report.Findings {
		if finding.Type == "insecure_code" {
			insecureCodeFound = true
			break
		}
	}
	suite.True(insecureCodeFound, "Should find insecure code patterns")
}

func (suite *VulnerabilityScanTestSuite) TestSecretDetection() {
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	// Create scanner that only scans for secrets
	config := &ScanConfig{
		ProjectRoot:      suite.testDir,
		ScanDependencies: false,
		ScanCode:         false,
		ScanSecrets:      true,
		ScanInsecureCode: false,
		Timeout:          30 * time.Second,
	}

	scanner, err := NewVulnerabilityScanner(config)
	suite.Require().NoError(err)

	report, err := scanner.Scan(ctx)
	suite.Require().NoError(err)

	// Should find AWS keys, GitHub token, database credentials, etc.
	awsKeyFound := false
	githubTokenFound := false
	dbCredentialsFound := false

	for _, finding := range report.Findings {
		switch finding.Title {
		case "AWS Access Key":
			awsKeyFound = true
		case "GitHub Token":
			githubTokenFound = true
		case "Database Connection String":
			dbCredentialsFound = true
		}
	}

	suite.True(awsKeyFound, "Should detect AWS access key")
	suite.True(githubTokenFound, "Should detect GitHub token")
	suite.True(dbCredentialsFound, "Should detect database credentials")
}

func (suite *VulnerabilityScanTestSuite) TestInsecureCodeDetection() {
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	// Create scanner that only scans for insecure code
	config := &ScanConfig{
		ProjectRoot:      suite.testDir,
		ScanDependencies: false,
		ScanCode:         true,
		ScanSecrets:      false,
		ScanInsecureCode: true,
		Timeout:          30 * time.Second,
	}

	scanner, err := NewVulnerabilityScanner(config)
	suite.Require().NoError(err)

	report, err := scanner.Scan(ctx)
	suite.Require().NoError(err)

	// Should find MD5 usage, SHA1 usage, command injection, etc.
	md5Found := false
	sha1Found := false
	commandInjectionFound := false

	for _, finding := range report.Findings {
		switch finding.Title {
		case "MD5 Usage":
			md5Found = true
		case "SHA1 Usage":
			sha1Found = true
		case "Command Injection Risk":
			commandInjectionFound = true
		}
	}

	suite.True(md5Found, "Should detect MD5 usage")
	suite.True(sha1Found, "Should detect SHA1 usage")
	suite.True(commandInjectionFound, "Should detect potential command injection")
}

func (suite *VulnerabilityScanTestSuite) TestReportGeneration() {
	ctx, cancel := context.WithTimeout(context.Background(), 1*time.Minute)
	defer cancel()

	report, err := suite.scanner.Scan(ctx)
	suite.Require().NoError(err)

	// Verify report contains all expected fields
	suite.NotEmpty(report.ScannerVersion)
	suite.NotZero(report.ScanTime)
	suite.NotZero(report.ScanDuration)
	suite.NotNil(report.FindingsByType)
	suite.NotNil(report.FindingsBySeverity)
	suite.NotNil(report.Summary)

	// Verify summary structure
	summary := report.Summary
	suite.GreaterOrEqual(summary.CriticalCount, 0)
	suite.GreaterOrEqual(summary.HighCount, 0)
	suite.GreaterOrEqual(summary.MediumCount, 0)
	suite.GreaterOrEqual(summary.LowCount, 0)
	suite.GreaterOrEqual(summary.InfoCount, 0)
	suite.GreaterOrEqual(summary.RiskScore, 0.0)
	suite.True(summary.PassFail == "PASS" || summary.PassFail == "FAIL")

	// Test that fail condition works for critical vulnerabilities
	if summary.CriticalCount > 0 {
		suite.Equal("FAIL", summary.PassFail, "Should fail when critical vulnerabilities are found")
	}
}

func (suite *VulnerabilityScanTestSuite) TestSaveAndLoadReport() {
	ctx, cancel := context.WithTimeout(context.Background(), 1*time.Minute)
	defer cancel()

	report, err := suite.scanner.Scan(ctx)
	suite.Require().NoError(err)

	// Save report to file
	reportPath := filepath.Join(suite.testDir, "security-report.json")
	err = suite.scanner.SaveReport(report, reportPath)
	suite.Require().NoError(err)

	// Verify file exists
	_, err = os.Stat(reportPath)
	suite.NoError(err)

	// Load report from file
	loadedReport, err := LoadReport(reportPath)
	suite.Require().NoError(err)

	// Verify loaded report matches original
	suite.Equal(report.ScannerVersion, loadedReport.ScannerVersion)
	suite.Equal(report.TotalFindings, loadedReport.TotalFindings)
	suite.Equal(len(report.Findings), len(loadedReport.Findings))
}

func (suite *VulnerabilityScanTestSuite) TestExclusionPatterns() {
	// Create a file that should be excluded
	excludeFile := filepath.Join(suite.testDir, "exclude_this.go")
	excludeCode := `
package main

func excludedFunction() {
	// This file should be excluded from scanning
	password := "excluded_password"
}
`
	err := os.WriteFile(excludeFile, []byte(excludeCode), 0644)
	suite.Require().NoError(err)
	defer os.Remove(excludeFile)

	// Create scanner with exclusion pattern
	config := &ScanConfig{
		ProjectRoot:      suite.testDir,
		ScanDependencies: false,
		ScanCode:         false,
		ScanSecrets:      true,
		ScanInsecureCode: false,
		ExcludePatterns:  []string{"exclude_this.go"},
		Timeout:          30 * time.Second,
	}

	scanner, err := NewVulnerabilityScanner(config)
	suite.Require().NoError(err)

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	report, err := scanner.Scan(ctx)
	suite.Require().NoError(err)

	// Should not find vulnerabilities in excluded file
	excludedFileFound := false
	for _, finding := range report.Findings {
		if finding.File == excludeFile {
			excludedFileFound = true
			break
		}
	}

	suite.False(excludedFileFound, "Should not find vulnerabilities in excluded files")
}

func (suite *VulnerabilityScanTestSuite) TestScanTimeout() {
	// Create scanner with very short timeout
	config := &ScanConfig{
		ProjectRoot:      suite.testDir,
		ScanDependencies: true,
		ScanCode:         true,
		ScanSecrets:      true,
		ScanInsecureCode: true,
		Timeout:          1 * time.Millisecond, // Very short timeout
	}

	scanner, err := NewVulnerabilityScanner(config)
	suite.Require().NoError(err)

	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Scan should be canceled due to timeout
	_, err = scanner.Scan(ctx)
	suite.Error(err, "Should return error when scan times out")
}

func (suite *VulnerabilityScanTestSuite) TestEmptyProjectScan() {
	// Create scanner for empty directory
	emptyDir, err := os.MkdirTemp("", "empty-scan-test")
	suite.Require().NoError(err)
	defer os.RemoveAll(emptyDir)

	config := &ScanConfig{
		ProjectRoot:      emptyDir,
		ScanDependencies: true,
		ScanCode:         true,
		ScanSecrets:      true,
		ScanInsecureCode: true,
		Timeout:          30 * time.Second,
	}

	scanner, err := NewVulnerabilityScanner(config)
	suite.Require().NoError(err)

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	report, err := scanner.Scan(ctx)
	suite.Require().NoError(err)

	// Should have no findings
	suite.Equal(0, report.TotalFindings, "Empty project should have no findings")
	suite.Equal(0, report.Summary.CriticalCount)
	suite.Equal("PASS", report.Summary.PassFail, "Empty project should pass security scan")
}

// Run the test suite
func TestVulnerabilityScanSuite(t *testing.T) {
	suite.Run(t, new(VulnerabilityScanTestSuite))
}

// Integration test for the actual project
func TestProjectSecurityScan(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping full project security scan in short mode")
	}

	// Scan the current project
	config := &ScanConfig{
		ProjectRoot:      "../..", // Go up to project root
		ScanDependencies: true,
		ScanCode:         true,
		ScanSecrets:      true,
		ScanInsecureCode: true,
		Timeout:          5 * time.Minute,
		ExcludePatterns: []string{
			"vendor/*",
			".git/*",
			"node_modules/*",
			"*.test",
		},
	}

	scanner, err := NewVulnerabilityScanner(config)
	require.NoError(t, err)

	ctx, cancel := context.WithTimeout(context.Background(), 6*time.Minute)
	defer cancel()

	report, err := scanner.Scan(ctx)
	assert.NoError(t, err)
	assert.NotNil(t, report)

	// Print summary for manual inspection
	t.Logf("Security scan completed with %d findings", report.TotalFindings)
	t.Logf("Critical: %d, High: %d, Medium: %d, Low: %d",
		report.Summary.CriticalCount, report.Summary.HighCount,
		report.Summary.MediumCount, report.Summary.LowCount)
	t.Logf("Risk Score: %.2f, Result: %s", report.Summary.RiskScore, report.Summary.PassFail)

	// Save report for inspection
	reportPath := "security-report.json"
	err = scanner.SaveReport(report, reportPath)
	assert.NoError(t, err)
	t.Logf("Security report saved to %s", reportPath)

	// In a real CI/CD pipeline, you would fail the build if critical issues are found
	if report.Summary.PassFail == "FAIL" {
		t.Logf("⚠️  SECURITY SCAN FAILED - Address critical and high severity issues")
	}
}