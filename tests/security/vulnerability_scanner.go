package security

import (
	"bufio"
	"context"
	"encoding/json"
	"erpgo/pkg/security"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"github.com/google/uuid"
)

// VulnerabilityScanner performs comprehensive security vulnerability scanning
type VulnerabilityScanner struct {
	config          *ScanConfig
	logger          *log.Logger
	findings        []VulnerabilityFinding
	dependencyCache map[string]bool
	scanStartTime   time.Time
}

// ScanConfig holds configuration for vulnerability scanning
type ScanConfig struct {
	ProjectRoot      string            `json:"project_root"`
	ScanDependencies bool              `json:"scan_dependencies"`
	ScanCode         bool              `json:"scan_code"`
	ScanSecrets      bool              `json:"scan_secrets"`
	ScanInsecureCode bool              `json:"scan_insecure_code"`
	MaxDepth         int               `json:"max_depth"`
	ExcludePatterns  []string          `json:"exclude_patterns"`
	Timeout          time.Duration     `json:"timeout"`
	SecretPatterns   []SecretPattern   `json:"secret_patterns"`
	InsecurePatterns []InsecurePattern `json:"insecure_patterns"`
}

// SecretPattern defines patterns for secret detection
type SecretPattern struct {
	Name        string `json:"name"`
	Pattern     string `json:"pattern"`
	Description string `json:"description"`
	Severity    string `json:"severity"`
}

// InsecurePattern defines patterns for insecure code detection
type InsecurePattern struct {
	Name        string `json:"name"`
	Pattern     string `json:"pattern"`
	Description string `json:"description"`
	Severity    string `json:"severity"`
	Fix         string `json:"fix"`
}

// VulnerabilityFinding represents a security vulnerability finding
type VulnerabilityFinding struct {
	ID             uuid.UUID `json:"id"`
	Type           string    `json:"type"`
	Severity       string    `json:"severity"`
	Title          string    `json:"title"`
	Description    string    `json:"description"`
	File           string    `json:"file"`
	Line           int       `json:"line"`
	Column         int       `json:"column"`
	Code           string    `json:"code"`
	Recommendation string    `json:"recommendation"`
	CVE            string    `json:"cve,omitempty"`
	CVSSScore      float64   `json:"cvss_score,omitempty"`
	ScanTime       time.Time `json:"scan_time"`
}

// ScanReport represents the complete vulnerability scan report
type ScanReport struct {
	ScannerVersion     string                 `json:"scanner_version"`
	ScanTime           time.Time              `json:"scan_time"`
	ScanDuration       time.Duration          `json:"scan_duration"`
	TotalFindings      int                    `json:"total_findings"`
	FindingsByType     map[string]int         `json:"findings_by_type"`
	FindingsBySeverity map[string]int         `json:"findings_by_severity"`
	Findings           []VulnerabilityFinding `json:"findings"`
	Summary            ScanSummary            `json:"summary"`
}

// ScanSummary provides a high-level summary of scan results
type ScanSummary struct {
	CriticalCount int     `json:"critical_count"`
	HighCount     int     `json:"high_count"`
	MediumCount   int     `json:"medium_count"`
	LowCount      int     `json:"low_count"`
	InfoCount     int     `json:"info_count"`
	RiskScore     float64 `json:"risk_score"`
	PassFail      string  `json:"pass_fail"`
}

// DefaultScanConfig returns a secure default configuration
func DefaultScanConfig() *ScanConfig {
	return &ScanConfig{
		ProjectRoot:      ".",
		ScanDependencies: true,
		ScanCode:         true,
		ScanSecrets:      true,
		ScanInsecureCode: true,
		MaxDepth:         10,
		Timeout:          30 * time.Minute,
		SecretPatterns: []SecretPattern{
			{
				Name:        "AWS Access Key",
				Pattern:     `AKIA[0-9A-Z]{16}`,
				Description: "AWS Access Key ID detected",
				Severity:    "critical",
			},
			{
				Name:        "AWS Secret Key",
				Pattern:     `[A-Za-z0-9/+=]{40}`,
				Description: "Potential AWS Secret Key detected",
				Severity:    "critical",
			},
			{
				Name:        "Generic API Key",
				Pattern:     `(api[_-]?key|apikey)\s*[:=]\s*['\"]([a-zA-Z0-9_-]{20,})['\"]`,
				Description: "Generic API key detected",
				Severity:    "high",
			},
			{
				Name:        "Database Connection String",
				Pattern:     `(mysql|postgresql|mongodb)://[^\s'"]*:[^\s'"]*@`,
				Description: "Database connection string with credentials",
				Severity:    "high",
			},
			{
				Name:        "Private Key",
				Pattern:     `-----BEGIN (RSA |DSA |EC |OPENSSH )?PRIVATE KEY-----`,
				Description: "Private key detected in source code",
				Severity:    "critical",
			},
			{
				Name:        "Password in Code",
				Pattern:     `(password|passwd|pwd)\s*[:=]\s*['\"]([^\s'"]{8,})['\"]`,
				Description: "Hardcoded password detected",
				Severity:    "high",
			},
			{
				Name:        "JWT Secret",
				Pattern:     `(jwt[_-]?secret)\s*[:=]\s*['\"]([^\s'"]{16,})['\"]`,
				Description: "JWT secret detected in source code",
				Severity:    "high",
			},
			{
				Name:        "GitHub Token",
				Pattern:     `ghp_[a-zA-Z0-9]{36}`,
				Description: "GitHub personal access token detected",
				Severity:    "critical",
			},
		},
		InsecurePatterns: []InsecurePattern{
			{
				Name:        "SQL Injection Risk",
				Pattern:     `fmt\.Sprintf.*%s.*sql`,
				Description: "Potential SQL injection vulnerability with string formatting",
				Severity:    "high",
				Fix:         "Use parameterized queries or prepared statements",
			},
			{
				Name:        "Hardcoded TLS Configuration",
				Pattern:     `&tls\.Config{[^}]*InsecureSkipVerify:\s*true`,
				Description: "TLS certificate verification is disabled",
				Severity:    "high",
				Fix:         "Enable proper certificate verification",
			},
			{
				Name:        "Weak Random Number Generation",
				Pattern:     `math/rand\.`,
				Description: "Using math/rand for security-sensitive operations",
				Severity:    "medium",
				Fix:         "Use crypto/rand for cryptographic operations",
			},
			{
				Name:        "MD5 Usage",
				Pattern:     `crypto/md5`,
				Description: "MD5 hash algorithm is cryptographically weak",
				Severity:    "medium",
				Fix:         "Use stronger hash algorithms like SHA-256 or SHA-3",
			},
			{
				Name:        "SHA1 Usage",
				Pattern:     `crypto/sha1`,
				Description: "SHA1 hash algorithm is cryptographically weak",
				Severity:    "medium",
				Fix:         "Use stronger hash algorithms like SHA-256 or SHA-3",
			},
			{
				Name:        "Unsafe Deserialization",
				Pattern:     `json\.Unmarshal.*interface`,
				Description: "Unsafe JSON unmarshaling without type checking",
				Severity:    "medium",
				Fix:         "Unmarshal to specific types with validation",
			},
			{
				Name:        "Path Traversal Risk",
				Pattern:     `filepath\.Join.*\.\.`,
				Description: "Potential path traversal vulnerability",
				Severity:    "medium",
				Fix:         "Validate and sanitize file paths",
			},
			{
				Name:        "Command Injection Risk",
				Pattern:     `exec\.Command.*fmt\.Sprintf`,
				Description: "Potential command injection with string formatting",
				Severity:    "critical",
				Fix:         "Use safe parameter passing and avoid string formatting",
			},
			{
				Name:        "Debug Endpoint",
				Pattern:     `pprint|fmt\.Print.*password|log\.Print.*password`,
				Description: "Sensitive information potentially logged",
				Severity:    "low",
				Fix:         "Remove logging of sensitive information",
			},
		},
	}
}

// NewVulnerabilityScanner creates a new vulnerability scanner
func NewVulnerabilityScanner(config *ScanConfig) (*VulnerabilityScanner, error) {
	if config == nil {
		config = DefaultScanConfig()
	}

	logger := log.New(os.Stdout, "[SECURITY-SCAN] ", log.LstdFlags)

	return &VulnerabilityScanner{
		config:          config,
		logger:          logger,
		findings:        make([]VulnerabilityFinding, 0),
		dependencyCache: make(map[string]bool),
		scanStartTime:   time.Now(),
	}, nil
}

// Scan performs a comprehensive vulnerability scan
func (s *VulnerabilityScanner) Scan(ctx context.Context) (*ScanReport, error) {
	s.logger.Printf("Starting vulnerability scan of project: %s", s.config.ProjectRoot)
	s.scanStartTime = time.Now()

	// Create scan context with timeout
	scanCtx, cancel := context.WithTimeout(ctx, s.config.Timeout)
	defer cancel()

	// Perform different types of scans
	if s.config.ScanDependencies {
		s.logger.Println("Scanning dependencies for known vulnerabilities...")
		s.scanDependencies(scanCtx)
	}

	if s.config.ScanCode {
		s.logger.Println("Scanning source code for security issues...")
		s.scanSourceCode(scanCtx)
	}

	if s.config.ScanSecrets {
		s.logger.Println("Scanning for exposed secrets...")
		s.scanForSecrets(scanCtx)
	}

	if s.config.ScanInsecureCode {
		s.logger.Println("Scanning for insecure code patterns...")
		s.scanForInsecureCode(scanCtx)
	}

	// Generate report
	report := s.generateReport()

	s.logger.Printf("Scan completed. Found %d vulnerabilities", report.TotalFindings)
	s.logger.Printf("Risk Score: %.2f (%s)", report.Summary.RiskScore, report.Summary.PassFail)

	return report, nil
}

// scanDependencies scans project dependencies for known vulnerabilities
func (s *VulnerabilityScanner) scanDependencies(ctx context.Context) {
	// Read go.mod file
	goModPath := filepath.Join(s.config.ProjectRoot, "go.mod")

	// Validate path before opening file
	if err := security.ValidatePath(goModPath, s.config.ProjectRoot); err != nil {
		s.logger.Printf("Warning: Invalid go.mod path: %v", err)
		return
	}

	goModFile, err := os.Open(goModPath)
	if err != nil {
		s.logger.Printf("Warning: Could not read go.mod file: %v", err)
		return
	}
	defer goModFile.Close()

	// Parse dependencies
	scanner := bufio.NewScanner(goModFile)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if strings.HasPrefix(line, "require") || strings.HasPrefix(line, "\t") {
			parts := strings.Fields(line)
			if len(parts) >= 2 {
				moduleName := strings.Trim(parts[0], "\t\"")
				version := strings.Trim(parts[1], "\"")

				// Check for known vulnerabilities
				s.checkModuleVulnerability(ctx, moduleName, version)
			}
		}
	}
}

// checkModuleVulnerability checks a specific module for known vulnerabilities
func (s *VulnerabilityScanner) checkModuleVulnerability(ctx context.Context, module, version string) {
	// Cache check
	cacheKey := fmt.Sprintf("%s@%s", module, version)
	if s.dependencyCache[cacheKey] {
		return
	}

	// Mock vulnerability check for demo purposes
	// In a real implementation, you would use golang.org/x/vuln/client
	knownVulns := map[string][]string{
		"github.com/gorilla/websocket": {"CVE-2020-27816"},
		"golang.org/x/crypto":          {"CVE-2020-29662"},
	}

	if vulns, exists := knownVulns[module]; exists {
		for _, cve := range vulns {
			finding := VulnerabilityFinding{
				ID:             uuid.New(),
				Type:           "dependency",
				Severity:       "medium",
				Title:          fmt.Sprintf("Vulnerability in %s", module),
				Description:    fmt.Sprintf("Known vulnerability %s in module %s", cve, module),
				File:           "go.mod",
				CVE:            cve,
				CVSSScore:      6.5,
				ScanTime:       time.Now(),
				Recommendation: "Update to a patched version of the dependency",
			}

			s.findings = append(s.findings, finding)
		}
	}

	s.dependencyCache[cacheKey] = true
}

// scanSourceCode performs static analysis on source code
func (s *VulnerabilityScanner) scanSourceCode(ctx context.Context) {
	err := filepath.Walk(s.config.ProjectRoot, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip excluded patterns
		for _, pattern := range s.config.ExcludePatterns {
			if matched, _ := filepath.Match(pattern, path); matched {
				return nil
			}
		}

		// Only scan Go files
		if strings.HasSuffix(path, ".go") {
			s.analyzeGoFile(path)
		}

		return nil
	})

	if err != nil {
		s.logger.Printf("Error scanning source code: %v", err)
	}
}

// analyzeGoFile performs static analysis on a Go file
func (s *VulnerabilityScanner) analyzeGoFile(filePath string) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filePath, nil, parser.AllErrors|parser.ParseComments)
	if err != nil {
		s.logger.Printf("Error parsing file %s: %v", filePath, err)
		return
	}

	// Walk AST to find potential issues
	ast.Inspect(node, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.CallExpr:
			s.analyzeFunctionCall(fset, filePath, x)
		case *ast.ImportSpec:
			s.analyzeImport(fset, filePath, x)
		}

		return true
	})
}

// analyzeFunctionCall analyzes function calls for security issues
func (s *VulnerabilityScanner) analyzeFunctionCall(fset *token.FileSet, filePath string, call *ast.CallExpr) {
	// Check for potentially dangerous functions
	if ident, ok := call.Fun.(*ast.Ident); ok {
		switch ident.Name {
		case "exec.Command":
			s.addFinding("insecure_code", "high", "Use of exec.Command detected",
				"Potential command injection vulnerability", filePath,
				fset.Position(call.Pos()).Line, fset.Position(call.Pos()).Column,
				"exec.Command", "Validate all inputs and avoid string formatting for commands")

		case "sql.Query", "sql.Exec":
			s.addFinding("insecure_code", "medium", "Direct SQL execution detected",
				"Potential SQL injection vulnerability", filePath,
				fset.Position(call.Pos()).Line, fset.Position(call.Pos()).Column,
				"sql.Query", "Use parameterized queries")
		}
	}
}

// analyzeImport analyzes import statements for security issues
func (s *VulnerabilityScanner) analyzeImport(fset *token.FileSet, filePath string, importSpec *ast.ImportSpec) {
	if importSpec.Path != nil {
		importPath := importSpec.Path.Value

		// Check for potentially insecure imports
		insecureImports := map[string]string{
			"crypto/md5":   "MD5 is cryptographically weak",
			"crypto/sha1":  "SHA1 is cryptographically weak",
			"math/rand":    "Use crypto/rand for security-sensitive operations",
			"encoding/gob": "Gob serialization can be unsafe",
		}

		for insecureImport, reason := range insecureImports {
			if strings.Contains(importPath, insecureImport) {
				s.addFinding("insecure_code", "medium", fmt.Sprintf("Use of insecure import: %s", insecureImport),
					reason, filePath, fset.Position(importSpec.Pos()).Line, fset.Position(importSpec.Pos()).Column,
					importPath, "Use more secure alternatives")
			}
		}
	}
}

// scanForSecrets scans files for exposed secrets
func (s *VulnerabilityScanner) scanForSecrets(ctx context.Context) {
	err := filepath.Walk(s.config.ProjectRoot, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip excluded patterns and binary files
		for _, pattern := range s.config.ExcludePatterns {
			if matched, _ := filepath.Match(pattern, path); matched {
				return nil
			}
		}

		// Skip binary files
		if s.isBinaryFile(path) {
			return nil
		}

		s.scanFileForSecrets(path)
		return nil
	})

	if err != nil {
		s.logger.Printf("Error scanning for secrets: %v", err)
	}
}

// scanFileForSecrets scans a single file for secrets
func (s *VulnerabilityScanner) scanFileForSecrets(filePath string) {
	// Validate path before opening file
	if err := security.ValidatePath(filePath, s.config.ProjectRoot); err != nil {
		s.logger.Printf("Warning: Invalid file path for secret scanning: %v", err)
		return
	}

	file, err := os.Open(filePath)
	if err != nil {
		return
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	lineNum := 0

	for scanner.Scan() {
		lineNum++
		line := scanner.Text()

		for _, pattern := range s.config.SecretPatterns {
			re, err := regexp.Compile(pattern.Pattern)
			if err != nil {
				continue
			}

			if matches := re.FindAllStringSubmatch(line, -1); len(matches) > 0 {
				s.addFinding("exposed_secret", pattern.Severity, pattern.Name,
					pattern.Description, filePath, lineNum, 0,
					line, "Remove secrets from code and use secure configuration")
			}
		}
	}
}

// scanForInsecureCode scans files for insecure code patterns
func (s *VulnerabilityScanner) scanForInsecureCode(ctx context.Context) {
	err := filepath.Walk(s.config.ProjectRoot, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Only scan Go files
		if strings.HasSuffix(path, ".go") {
			s.scanFileForInsecurePatterns(path)
		}

		return nil
	})

	if err != nil {
		s.logger.Printf("Error scanning for insecure code: %v", err)
	}
}

// scanFileForInsecurePatterns scans a Go file for insecure patterns
func (s *VulnerabilityScanner) scanFileForInsecurePatterns(filePath string) {
	// Validate path before opening file
	if err := security.ValidatePath(filePath, s.config.ProjectRoot); err != nil {
		s.logger.Printf("Warning: Invalid file path for insecure pattern scanning: %v", err)
		return
	}

	file, err := os.Open(filePath)
	if err != nil {
		return
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	lineNum := 0

	for scanner.Scan() {
		lineNum++
		line := scanner.Text()

		for _, pattern := range s.config.InsecurePatterns {
			re, err := regexp.Compile(pattern.Pattern)
			if err != nil {
				continue
			}

			if re.MatchString(line) {
				s.addFinding("insecure_code", pattern.Severity, pattern.Name,
					pattern.Description, filePath, lineNum, 0,
					line, pattern.Fix)
			}
		}
	}
}

// isBinaryFile checks if a file is binary
func (s *VulnerabilityScanner) isBinaryFile(filePath string) bool {
	// Validate path before opening file
	if err := security.ValidatePath(filePath, s.config.ProjectRoot); err != nil {
		s.logger.Printf("Warning: Invalid file path for binary check: %v", err)
		return true
	}

	file, err := os.Open(filePath)
	if err != nil {
		return true
	}
	defer file.Close()

	buffer := make([]byte, 512)
	_, err = file.Read(buffer)
	if err != nil {
		return true
	}

	// Check for null byte (common in binary files)
	for _, b := range buffer {
		if b == 0 {
			return true
		}
	}

	return false
}

// addFinding adds a vulnerability finding
func (s *VulnerabilityScanner) addFinding(findingType, severity, title, description, file string, line, column int, code, recommendation string) {
	finding := VulnerabilityFinding{
		ID:             uuid.New(),
		Type:           findingType,
		Severity:       severity,
		Title:          title,
		Description:    description,
		File:           file,
		Line:           line,
		Column:         column,
		Code:           code,
		Recommendation: recommendation,
		ScanTime:       time.Now(),
	}

	s.findings = append(s.findings, finding)
}

// getSeverityFromCVSS converts CVSS score to severity level
func (s *VulnerabilityScanner) getSeverityFromCVSS(score float64) string {
	switch {
	case score >= 9.0:
		return "critical"
	case score >= 7.0:
		return "high"
	case score >= 4.0:
		return "medium"
	case score > 0:
		return "low"
	default:
		return "info"
	}
}

// generateReport generates the final scan report
func (s *VulnerabilityScanner) generateReport() *ScanReport {
	scanDuration := time.Since(s.scanStartTime)

	// Count findings by type and severity
	findingsByType := make(map[string]int)
	findingsBySeverity := make(map[string]int)

	summary := ScanSummary{}

	for _, finding := range s.findings {
		findingsByType[finding.Type]++
		findingsBySeverity[finding.Severity]++

		switch finding.Severity {
		case "critical":
			summary.CriticalCount++
		case "high":
			summary.HighCount++
		case "medium":
			summary.MediumCount++
		case "low":
			summary.LowCount++
		case "info":
			summary.InfoCount++
		}
	}

	// Calculate risk score
	summary.RiskScore = s.calculateRiskScore(summary)
	summary.PassFail = s.determinePassFail(summary)

	return &ScanReport{
		ScannerVersion:     "1.0.0",
		ScanTime:           s.scanStartTime,
		ScanDuration:       scanDuration,
		TotalFindings:      len(s.findings),
		FindingsByType:     findingsByType,
		FindingsBySeverity: findingsBySeverity,
		Findings:           s.findings,
		Summary:            summary,
	}
}

// calculateRiskScore calculates the overall risk score
func (s *VulnerabilityScanner) calculateRiskScore(summary ScanSummary) float64 {
	score := float64(0)

	// Weight critical findings highest
	score += float64(summary.CriticalCount) * 10
	score += float64(summary.HighCount) * 5
	score += float64(summary.MediumCount) * 2
	score += float64(summary.LowCount) * 1

	// Normalize to 0-100 scale
	if score > 100 {
		score = 100
	}

	return score
}

// determinePassFail determines if the scan passes or fails
func (s *VulnerabilityScanner) determinePassFail(summary ScanSummary) string {
	if summary.CriticalCount > 0 || summary.HighCount > 5 {
		return "FAIL"
	}
	if summary.MediumCount > 10 {
		return "FAIL"
	}
	if summary.RiskScore > 50 {
		return "FAIL"
	}
	return "PASS"
}

// SaveReport saves a scan report to a file
func (s *VulnerabilityScanner) SaveReport(report *ScanReport, filePath string) error {
	// Validate path before creating file
	// For saving reports, we'll use the directory of the file as the allowed root
	reportDir := filepath.Dir(filePath)
	if err := security.ValidatePath(filePath, reportDir); err != nil {
		return fmt.Errorf("invalid report file path: %w", err)
	}

	file, err := os.Create(filePath)
	if err != nil {
		return err
	}
	defer file.Close()

	encoder := json.NewEncoder(file)
	encoder.SetIndent("", "  ")
	return encoder.Encode(report)
}

// LoadReport loads a scan report from a file
func LoadReport(filePath string) (*ScanReport, error) {
	// Validate path before opening file
	// For loading reports, we'll use the directory of the file as the allowed root
	reportDir := filepath.Dir(filePath)
	if err := security.ValidatePath(filePath, reportDir); err != nil {
		return nil, fmt.Errorf("invalid report file path: %w", err)
	}

	file, err := os.Open(filePath)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var report ScanReport
	decoder := json.NewDecoder(file)
	err = decoder.Decode(&report)
	if err != nil {
		return nil, err
	}

	return &report, nil
}

// PrintSummary prints a summary of the scan results
func (s *VulnerabilityScanner) PrintSummary(report *ScanReport) {
	fmt.Printf("\n=== Security Vulnerability Scan Report ===\n")
	fmt.Printf("Scan Time: %s\n", report.ScanTime.Format(time.RFC3339))
	fmt.Printf("Scan Duration: %s\n", report.ScanDuration)
	fmt.Printf("Total Findings: %d\n", report.TotalFindings)

	fmt.Printf("\nFindings by Severity:\n")
	fmt.Printf("  Critical: %d\n", report.Summary.CriticalCount)
	fmt.Printf("  High: %d\n", report.Summary.HighCount)
	fmt.Printf("  Medium: %d\n", report.Summary.MediumCount)
	fmt.Printf("  Low: %d\n", report.Summary.LowCount)
	fmt.Printf("  Info: %d\n", report.Summary.InfoCount)

	fmt.Printf("\nRisk Score: %.2f\n", report.Summary.RiskScore)
	fmt.Printf("Result: %s\n", report.Summary.PassFail)

	if report.Summary.PassFail == "FAIL" {
		fmt.Printf("\n⚠️  SECURITY SCAN FAILED - Address critical and high severity issues before deployment\n")
	} else {
		fmt.Printf("\n✅ SECURITY SCAN PASSED - No critical security issues detected\n")
	}

	fmt.Printf("\nTop Findings:\n")
	for i, finding := range report.Findings {
		if i >= 10 { // Show top 10 findings
			break
		}
		fmt.Printf("  %d. [%s] %s in %s:%d\n", i+1, strings.ToUpper(finding.Severity),
			finding.Title, finding.File, finding.Line)
	}
}
